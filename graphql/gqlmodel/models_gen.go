// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlmodel

import (
	"fmt"
	"io"
	"strconv"
)

type AnkiConnectionPayload interface {
	IsAnkiConnectionPayload()
}

type AnkiDeckPayload interface {
	IsAnkiDeckPayload()
}

type AnkiMappingPayload interface {
	IsAnkiMappingPayload()
}

type AnkiNoteTypePayload interface {
	IsAnkiNoteTypePayload()
}

type AnkiStatePayload interface {
	IsAnkiStatePayload()
}

type Error interface {
	IsError()
	GetMessage() string
}

type AnkiConfig struct {
	Addr     string                `json:"addr"`
	APIKey   string                `json:"apiKey"`
	Deck     string                `json:"deck"`
	NoteType string                `json:"noteType"`
	Mapping  []*AnkiMappingElement `json:"mapping"`
}

type AnkiConnectionError struct {
	Message string `json:"message"`
}

func (AnkiConnectionError) IsError()                {}
func (this AnkiConnectionError) GetMessage() string { return this.Message }

func (AnkiConnectionError) IsAnkiStatePayload() {}

type AnkiConnectionInput struct {
	Addr   string `json:"addr"`
	APIKey string `json:"apiKey"`
}

type AnkiDeckInput struct {
	Name string `json:"name"`
}

type AnkiMappingElement struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type AnkiMappingElementError struct {
	Key     string `json:"key"`
	Message string `json:"message"`
}

type AnkiMappingElementInput struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type AnkiMappingError struct {
	FieldErrors []*AnkiMappingElementError `json:"fieldErrors,omitempty"`
	ValueErrors []*AnkiMappingElementError `json:"valueErrors,omitempty"`
	Message     string                     `json:"message"`
}

func (AnkiMappingError) IsError()                {}
func (this AnkiMappingError) GetMessage() string { return this.Message }

func (AnkiMappingError) IsAnkiMappingPayload() {}

type AnkiMappingInput struct {
	Mapping []*AnkiMappingElementInput `json:"mapping"`
}

type AnkiNoteTypeInput struct {
	Name string `json:"name"`
}

type AnkiState struct {
	Version           int      `json:"version"`
	Connected         bool     `json:"connected"`
	PermissionGranted bool     `json:"permissionGranted"`
	APIKeyRequired    bool     `json:"apiKeyRequired"`
	DeckExists        bool     `json:"deckExists"`
	NoteTypeExists    bool     `json:"noteTypeExists"`
	NoteMissingFields []string `json:"noteMissingFields"`
}

func (AnkiState) IsAnkiStatePayload() {}

type Audio struct {
	Type   string `json:"type"`
	Source string `json:"source"`
}

type Furigana struct {
	Kanji    string `json:"kanji"`
	Hiragana string `json:"hiragana"`
}

type Lemma struct {
	Slug   *Word    `json:"slug"`
	Tags   []string `json:"tags"`
	Forms  []*Word  `json:"forms"`
	Senses []*Sense `json:"senses"`
	Audio  []*Audio `json:"audio"`
}

type Lemmas struct {
	Lemmas []*Lemma `json:"lemmas"`
}

type Pitch struct {
	Hiragana string      `json:"hiragana"`
	Pitch    []PitchType `json:"pitch"`
}

type Sense struct {
	Definition   []string `json:"definition"`
	PartOfSpeech []string `json:"partOfSpeech"`
	Tags         []string `json:"tags"`
}

type ValidationError struct {
	Paths   []string `json:"paths"`
	Message string   `json:"message"`
}

func (ValidationError) IsAnkiConnectionPayload() {}

func (ValidationError) IsAnkiDeckPayload() {}

func (ValidationError) IsAnkiNoteTypePayload() {}

func (ValidationError) IsError()                {}
func (this ValidationError) GetMessage() string { return this.Message }

type Word struct {
	Word     string      `json:"word"`
	Hiragana string      `json:"hiragana"`
	Furigana []*Furigana `json:"furigana"`
	Pitch    []*Pitch    `json:"pitch"`
}

type PitchType string

const (
	PitchTypeUp    PitchType = "UP"
	PitchTypeDown  PitchType = "DOWN"
	PitchTypeLeft  PitchType = "LEFT"
	PitchTypeRight PitchType = "RIGHT"
)

var AllPitchType = []PitchType{
	PitchTypeUp,
	PitchTypeDown,
	PitchTypeLeft,
	PitchTypeRight,
}

func (e PitchType) IsValid() bool {
	switch e {
	case PitchTypeUp, PitchTypeDown, PitchTypeLeft, PitchTypeRight:
		return true
	}
	return false
}

func (e PitchType) String() string {
	return string(e)
}

func (e *PitchType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PitchType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PitchType", str)
	}
	return nil
}

func (e PitchType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
