// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlmodel

import (
	"fmt"
	"io"
	"strconv"
)

type AnkiError interface {
	IsAnkiError()
}

type CreateAnkiDeckError interface {
	IsCreateAnkiDeckError()
}

type CreateAnkiNoteError interface {
	IsCreateAnkiNoteError()
}

type Error interface {
	IsError()
	GetMessage() string
}

type Anki struct {
	Decks      []string `json:"decks"`
	Notes      []string `json:"notes"`
	NoteFields []string `json:"noteFields"`
}

type AnkiConfig struct {
	Addr     string                `json:"addr"`
	APIKey   string                `json:"apiKey"`
	Deck     string                `json:"deck"`
	NoteType string                `json:"noteType"`
	Mapping  []*AnkiMappingElement `json:"mapping"`
}

type AnkiConfigMappingElementError struct {
	Key     string `json:"key"`
	Message string `json:"message"`
}

type AnkiConfigMappingElementInput struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type AnkiConfigMappingError struct {
	FieldErrors []*AnkiConfigMappingElementError `json:"fieldErrors,omitempty"`
	ValueErrors []*AnkiConfigMappingElementError `json:"valueErrors,omitempty"`
	Message     string                           `json:"message"`
}

func (AnkiConfigMappingError) IsError()                {}
func (this AnkiConfigMappingError) GetMessage() string { return this.Message }

type AnkiConfigState struct {
	Version          int  `json:"version"`
	DeckExists       bool `json:"deckExists"`
	NoteTypeExists   bool `json:"noteTypeExists"`
	NoteHasAllFields bool `json:"noteHasAllFields"`
}

type AnkiConfigStateResult struct {
	AnkiConfigState *AnkiConfigState `json:"ankiConfigState,omitempty"`
	Error           AnkiError        `json:"error,omitempty"`
}

type AnkiConnectionError struct {
	Message string `json:"message"`
}

func (AnkiConnectionError) IsError()                {}
func (this AnkiConnectionError) GetMessage() string { return this.Message }

func (AnkiConnectionError) IsAnkiError() {}

type AnkiMappingElement struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type AnkiPermissionError struct {
	Message string `json:"message"`
	Version int    `json:"version"`
}

func (AnkiPermissionError) IsError()                {}
func (this AnkiPermissionError) GetMessage() string { return this.Message }

func (AnkiPermissionError) IsAnkiError() {}

type AnkiResult struct {
	Anki  *Anki     `json:"anki,omitempty"`
	Error AnkiError `json:"error,omitempty"`
}

type AnkiUnauthorizedError struct {
	Message string `json:"message"`
	Version int    `json:"version"`
}

func (AnkiUnauthorizedError) IsError()                {}
func (this AnkiUnauthorizedError) GetMessage() string { return this.Message }

func (AnkiUnauthorizedError) IsAnkiError() {}

type Audio struct {
	Type   string `json:"type"`
	Source string `json:"source"`
}

type CreateAnkiDeckAlreadyExists struct {
	Message string `json:"message"`
}

func (CreateAnkiDeckAlreadyExists) IsError()                {}
func (this CreateAnkiDeckAlreadyExists) GetMessage() string { return this.Message }

func (CreateAnkiDeckAlreadyExists) IsCreateAnkiDeckError() {}

type CreateAnkiDeckInput struct {
	Name string `json:"name"`
}

type CreateAnkiDeckResult struct {
	AnkiError AnkiError           `json:"ankiError,omitempty"`
	Error     CreateAnkiDeckError `json:"error,omitempty"`
}

type CreateAnkiNoteAlreadyExists struct {
	Message string `json:"message"`
}

func (CreateAnkiNoteAlreadyExists) IsError()                {}
func (this CreateAnkiNoteAlreadyExists) GetMessage() string { return this.Message }

func (CreateAnkiNoteAlreadyExists) IsCreateAnkiNoteError() {}

type CreateAnkiNoteInput struct {
	Name string `json:"name"`
}

type CreateAnkiNoteResult struct {
	AnkiError AnkiError           `json:"AnkiError,omitempty"`
	Error     CreateAnkiDeckError `json:"Error,omitempty"`
}

type Furigana struct {
	Kanji    string `json:"kanji"`
	Hiragana string `json:"hiragana"`
}

type Lemma struct {
	Slug   *Word    `json:"slug"`
	Tags   []string `json:"tags"`
	Forms  []*Word  `json:"forms"`
	Senses []*Sense `json:"senses"`
	Audio  []*Audio `json:"audio"`
}

type Lemmas struct {
	Lemmas []*Lemma `json:"lemmas"`
}

type Pitch struct {
	Hiragana string      `json:"hiragana"`
	Pitch    []PitchType `json:"pitch"`
}

type Sense struct {
	Definition   []string `json:"definition"`
	PartOfSpeech []string `json:"partOfSpeech"`
	Tags         []string `json:"tags"`
}

type SetAnkiConfigConnectionInput struct {
	Addr   string `json:"addr"`
	APIKey string `json:"apiKey"`
}

type SetAnkiConfigConnectionResult struct {
	Error *ValidationError `json:"error,omitempty"`
}

type SetAnkiConfigDeckInput struct {
	Name string `json:"name"`
}

type SetAnkiConfigDeckResult struct {
	Error *ValidationError `json:"error,omitempty"`
}

type SetAnkiConfigMappingInput struct {
	Mapping []*AnkiConfigMappingElementInput `json:"mapping"`
}

type SetAnkiConfigMappingResult struct {
	Error *AnkiConfigMappingError `json:"error,omitempty"`
}

type SetAnkiConfigNote struct {
	Name string `json:"name"`
}

type SetAnkiConfigNoteResult struct {
	Error *ValidationError `json:"error,omitempty"`
}

type ValidationError struct {
	Paths   []string `json:"paths"`
	Message string   `json:"message"`
}

func (ValidationError) IsCreateAnkiDeckError() {}

func (ValidationError) IsCreateAnkiNoteError() {}

func (ValidationError) IsError()                {}
func (this ValidationError) GetMessage() string { return this.Message }

type Word struct {
	Word     string      `json:"word"`
	Hiragana string      `json:"hiragana"`
	Furigana []*Furigana `json:"furigana"`
	Pitch    []*Pitch    `json:"pitch"`
}

type PitchType string

const (
	PitchTypeUp    PitchType = "UP"
	PitchTypeDown  PitchType = "DOWN"
	PitchTypeLeft  PitchType = "LEFT"
	PitchTypeRight PitchType = "RIGHT"
)

var AllPitchType = []PitchType{
	PitchTypeUp,
	PitchTypeDown,
	PitchTypeLeft,
	PitchTypeRight,
}

func (e PitchType) IsValid() bool {
	switch e {
	case PitchTypeUp, PitchTypeDown, PitchTypeLeft, PitchTypeRight:
		return true
	}
	return false
}

func (e PitchType) String() string {
	return string(e)
}

func (e *PitchType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PitchType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PitchType", str)
	}
	return nil
}

func (e PitchType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
