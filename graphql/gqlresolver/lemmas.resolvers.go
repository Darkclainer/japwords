package gqlresolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"

	"github.com/Darkclainer/japwords/graphql/gqlgenerated"
	"github.com/Darkclainer/japwords/graphql/gqlmodel"
	"github.com/Darkclainer/japwords/pkg/lemma"
)

// Audio is the resolver for the audio field.
func (r *lemmaResolver) Audio(ctx context.Context, obj *lemma.Lemma) ([]*gqlmodel.Audio, error) {
	var audios []*gqlmodel.Audio
	for source, audio := range obj.Audio {
		audios = append(audios, &gqlmodel.Audio{
			Type:   source,
			Source: audio,
		})
	}
	return audios, nil
}

// Pitch is the resolver for the pitch field.
func (r *pitchResolver) Pitch(ctx context.Context, obj *lemma.PitchShape) ([]lemma.AccentDirection, error) {
	return obj.Directions, nil
}

// Furigana is the resolver for the furigana field.
func (r *wordResolver) Furigana(ctx context.Context, obj *lemma.Word) ([]*lemma.FuriganaChar, error) {
	return sliceToPointers(obj.Furigana), nil
}

// Pitch is the resolver for the pitch field.
func (r *wordResolver) Pitch(ctx context.Context, obj *lemma.Word) ([]*lemma.PitchShape, error) {
	return sliceToPointers(obj.PitchShapes()), nil
}

// Lemma returns gqlgenerated.LemmaResolver implementation.
func (r *Resolver) Lemma() gqlgenerated.LemmaResolver { return &lemmaResolver{r} }

// Pitch returns gqlgenerated.PitchResolver implementation.
func (r *Resolver) Pitch() gqlgenerated.PitchResolver { return &pitchResolver{r} }

// Word returns gqlgenerated.WordResolver implementation.
func (r *Resolver) Word() gqlgenerated.WordResolver { return &wordResolver{r} }

type lemmaResolver struct{ *Resolver }
type pitchResolver struct{ *Resolver }
type wordResolver struct{ *Resolver }
