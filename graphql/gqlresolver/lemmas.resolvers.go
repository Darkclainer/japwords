package gqlresolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"cmp"
	"context"
	"slices"

	"github.com/Darkclainer/japwords/graphql/gqlgenerated"
	"github.com/Darkclainer/japwords/graphql/gqlmodel"
	"github.com/Darkclainer/japwords/pkg/lemma"
)

// Audio is the resolver for the audio field.
func (r *lemmaResolver) Audio(ctx context.Context, obj *lemma.ProjectedLemma) ([]*gqlmodel.Audio, error) {
	var audios []*gqlmodel.Audio
	for source, audio := range obj.Audio {
		audios = append(audios, &gqlmodel.Audio{
			Type:   source,
			Source: audio,
		})
	}
	slices.SortFunc(audios, func(a, b *gqlmodel.Audio) int {
		return cmp.Compare(a.Type, b.Type)
	})
	return audios, nil
}

// Furigana is the resolver for the furigana field.
func (r *wordResolver) Furigana(ctx context.Context, obj *lemma.Word) ([]*lemma.FuriganaChar, error) {
	return sliceToPointers(obj.Furigana), nil
}

// Audio is the resolver for the audio field.
func (r *lemmaInputResolver) Audio(ctx context.Context, obj *lemma.ProjectedLemma, data []*gqlmodel.AudioInput) error {
	audios := make(map[string]string, len(data))
	for _, audio := range data {
		audios[audio.Type] = audio.Source
	}
	obj.Audio = audios
	return nil
}

// Furigana is the resolver for the furigana field.
func (r *wordInputResolver) Furigana(ctx context.Context, obj *lemma.Word, data []*lemma.FuriganaChar) error {
	obj.Furigana = sliceToValues(data)
	return nil
}

// Lemma returns gqlgenerated.LemmaResolver implementation.
func (r *Resolver) Lemma() gqlgenerated.LemmaResolver { return &lemmaResolver{r} }

// Word returns gqlgenerated.WordResolver implementation.
func (r *Resolver) Word() gqlgenerated.WordResolver { return &wordResolver{r} }

// LemmaInput returns gqlgenerated.LemmaInputResolver implementation.
func (r *Resolver) LemmaInput() gqlgenerated.LemmaInputResolver { return &lemmaInputResolver{r} }

// WordInput returns gqlgenerated.WordInputResolver implementation.
func (r *Resolver) WordInput() gqlgenerated.WordInputResolver { return &wordInputResolver{r} }

type lemmaResolver struct{ *Resolver }
type wordResolver struct{ *Resolver }
type lemmaInputResolver struct{ *Resolver }
type wordInputResolver struct{ *Resolver }
