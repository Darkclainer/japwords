package gqlresolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"cmp"
	"context"
	"errors"
	"slices"

	"github.com/Darkclainer/japwords/graphql/gqlgenerated"
	"github.com/Darkclainer/japwords/graphql/gqlmodel"
	"github.com/Darkclainer/japwords/pkg/anki"
	"github.com/Darkclainer/japwords/pkg/anki/ankiconnect"
)

// SetAnkiConnection is the resolver for the setAnkiConnection field.
func (r *mutationResolver) SetAnkiConnection(ctx context.Context, input gqlmodel.AnkiConnectionInput) (gqlmodel.AnkiConnectionPayload, error) {
	err := r.ankiConfig.UpdateConnection(input.Addr, input.APIKey)
	if err != nil {
		return convertAnkiValidationError(ctx, err)
	}
	return nil, nil
}

// SetAnkiDeck is the resolver for the setAnkiDeck field.
func (r *mutationResolver) SetAnkiDeck(ctx context.Context, input gqlmodel.AnkiDeckInput) (gqlmodel.AnkiDeckPayload, error) {
	err := r.ankiConfig.UpdateDeck(input.Name)
	if err != nil {
		return convertAnkiValidationError(ctx, err)
	}
	return nil, nil
}

// SetAnkiNoteType is the resolver for the setAnkiNoteType field.
func (r *mutationResolver) SetAnkiNoteType(ctx context.Context, input gqlmodel.AnkiNoteTypeInput) (gqlmodel.AnkiNoteTypePayload, error) {
	err := r.ankiConfig.UpdateNoteType(input.Name)
	if err != nil {
		return convertAnkiValidationError(ctx, err)
	}
	return nil, nil
}

// SetAnkiMapping is the resolver for the setAnkiMapping field.
func (r *mutationResolver) SetAnkiMapping(ctx context.Context, input gqlmodel.AnkiMappingInput) (gqlmodel.AnkiMappingPayload, error) {
	mapping := map[string]string{}
	for _, element := range input.Mapping {
		mapping[element.Key] = element.Value
	}
	err := r.ankiConfig.UpdateMapping(mapping)
	if err != nil {
		var ankiMappingErrs *anki.MappingValidationErrors
		if !errors.As(err, &ankiMappingErrs) {
			return nil, err
		}
		mappingErrs := &gqlmodel.AnkiMappingError{
			Message: "invalid mapping",
		}
		for _, err := range ankiMappingErrs.KeyErrors {
			mappingErrs.FieldErrors = append(mappingErrs.FieldErrors,
				&gqlmodel.AnkiMappingElementError{
					Key:     err.Key,
					Message: err.Msg,
				},
			)
		}
		for _, err := range ankiMappingErrs.ValueErrors {
			mappingErrs.ValueErrors = append(mappingErrs.ValueErrors,
				&gqlmodel.AnkiMappingElementError{
					Key:     err.Key,
					Message: err.Msg,
				},
			)
		}
		return mappingErrs, nil
	}
	return nil, nil
}

// AnkiState is the resolver for the AnkiState field.
func (r *queryResolver) AnkiState(ctx context.Context) (gqlmodel.AnkiStatePayload, error) {
	state, err := r.ankiClient.FullStateCheck(ctx)
	if err != nil {
		var connErr *ankiconnect.ConnectionError
		if !errors.As(err, &connErr) {
			return nil, err
		}
		return &gqlmodel.AnkiConnectionError{
			Message: err.Error(),
		}, nil
	}
	result := &gqlmodel.AnkiState{
		Version:           state.Version,
		Connected:         state.Connected,
		PermissionGranted: state.PermissionGranted,
		APIKeyRequired:    state.APIKeyRequired,
		DeckExists:        state.DeckExists,
		NoteTypeExists:    state.NoteTypeExists,
		NoteMissingFields: state.NoteMissingFields,
	}
	return result, nil
}

// AnkiConfig is the resolver for the AnkiConfig field.
func (r *queryResolver) AnkiConfig(ctx context.Context) (*gqlmodel.AnkiConfig, error) {
	ankiConfig := r.configManager.Current().Anki
	result := &gqlmodel.AnkiConfig{
		Addr:     ankiConfig.Addr,
		APIKey:   ankiConfig.APIKey,
		Deck:     ankiConfig.Deck,
		NoteType: ankiConfig.NoteType,
		Mapping:  nil,
	}
	mapping := make([]*gqlmodel.AnkiMappingElement, 0, len(ankiConfig.FieldMapping))
	for key, value := range ankiConfig.FieldMapping {
		mapping = append(mapping, &gqlmodel.AnkiMappingElement{
			Key:   key,
			Value: value,
		})
	}
	slices.SortStableFunc(mapping, func(a, b *gqlmodel.AnkiMappingElement) int {
		return cmp.Compare(a.Key, b.Key)
	})
	result.Mapping = mapping
	return result, nil
}

// Mutation returns gqlgenerated.MutationResolver implementation.
func (r *Resolver) Mutation() gqlgenerated.MutationResolver { return &mutationResolver{r} }

// Query returns gqlgenerated.QueryResolver implementation.
func (r *Resolver) Query() gqlgenerated.QueryResolver { return &queryResolver{r} }

type (
	mutationResolver struct{ *Resolver }
	queryResolver    struct{ *Resolver }
)
